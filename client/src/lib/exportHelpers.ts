import { BlockType } from "./blocks";
import { optimizeVoxelRegions, FillRegion } from "./voxelHelpers";

// Generate an mcfunction file with /fill commands
export const exportToMcFunction = (
  voxels: Record<string, BlockType>,
  startX: number = 0,
  startY: number = 0,
  startZ: number = 0
): string => {
  // Check if there are any voxels
  if (Object.keys(voxels).length === 0) {
    return "# Empty structure - no blocks to place";
  }
  
  // Find the dimensions of the structure
  let minX = Infinity, minY = Infinity, minZ = Infinity;
  let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
  
  for (const key of Object.keys(voxels)) {
    const [x, y, z] = key.split(',').map(Number);
    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    minZ = Math.min(minZ, z);
    maxX = Math.max(maxX, x);
    maxY = Math.max(maxY, y);
    maxZ = Math.max(maxZ, z);
  }
  
  // Calculate dimensions
  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const depth = maxZ - minZ + 1;
  
  // Optimize voxels into regions
  const regions = optimizeVoxelRegions(voxels, [width, height, depth]);
  
  // Generate header with information
  let mcfunction = [
    "# Generated by BlockForge",
    `# Structure dimensions: ${width}x${height}x${depth}`,
    `# Origin position: ${startX}, ${startY}, ${startZ}`,
    `# Block count: ${Object.keys(voxels).length}`,
    ""
  ].join("\n");
  
  // Generate /fill commands
  regions.forEach((region: FillRegion) => {
    const { start, end, blockType } = region;
    const [sx, sy, sz] = start;
    const [ex, ey, ez] = end;
    
    // Adjust for structure origin
    const worldX1 = startX + sx + minX;
    const worldY1 = startY + sy + minY;
    const worldZ1 = startZ + sz + minZ;
    const worldX2 = startX + ex + minX;
    const worldY2 = startY + ey + minY;
    const worldZ2 = startZ + ez + minZ;
    
    // Generate fill command
    mcfunction += `fill ${worldX1} ${worldY1} ${worldZ1} ${worldX2} ${worldY2} ${worldZ2} ${blockType}\n`;
  });
  
  return mcfunction;
};

// Helper to export as CSV if needed
export const exportToCSV = (
  voxels: Record<string, BlockType>,
  layer: number
): string => {
  // Find the dimensions of the structure
  let minX = Infinity, minZ = Infinity;
  let maxX = -Infinity, maxZ = -Infinity;
  
  // Filter voxels for the specified layer
  const layerVoxels: Record<string, BlockType> = {};
  for (const [key, blockType] of Object.entries(voxels)) {
    const [x, y, z] = key.split(',').map(Number);
    if (y === layer) {
      layerVoxels[`${x},${z}`] = blockType;
      minX = Math.min(minX, x);
      minZ = Math.min(minZ, z);
      maxX = Math.max(maxX, x);
      maxZ = Math.max(maxZ, z);
    }
  }
  
  // If no voxels in this layer, return empty CSV
  if (Object.keys(layerVoxels).length === 0) {
    return "# Empty layer";
  }
  
  // Generate CSV
  let csv = "";
  for (let z = minZ; z <= maxZ; z++) {
    const row: string[] = [];
    for (let x = minX; x <= maxX; x++) {
      const key = `${x},${z}`;
      row.push(layerVoxels[key] || "");
    }
    csv += row.join(",") + "\n";
  }
  
  return csv;
};

// Export the project as JSON
export const exportToJSON = (
  voxels: Record<string, BlockType>,
  dimensions: [number, number, number]
): string => {
  const project = {
    version: "1.0.0",
    dimensions,
    voxels
  };
  
  return JSON.stringify(project, null, 2);
};

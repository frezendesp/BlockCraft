import { BlockType } from "./blocks";
import { optimizeVoxelRegions, FillRegion, parseVoxelKey } from "./voxelHelpers";

// Helper function to check if a position has a block
const hasBlock = (voxels: Record<string, BlockType>, x: number, y: number, z: number): boolean => {
  return voxels[`${x},${y},${z}`] !== undefined;
};

// Helper function to identify internal spaces
const findInternalSpaces = (
  voxels: Record<string, BlockType>,
  minX: number, minY: number, minZ: number,
  maxX: number, maxY: number, maxZ: number
): [number, number, number][] => {
  const internalSpaces: [number, number, number][] = [];
  
  // Check each potential internal position
  for (let y = minY; y <= maxY; y++) {
    for (let z = minZ; z <= maxZ; z++) {
      for (let x = minX; x <= maxX; x++) {
        // Skip positions that already have blocks
        if (hasBlock(voxels, x, y, z)) continue;
        
        // Check if this position is internal (surrounded by blocks)
        let isInternal = true;
        
        // Check if there's a clear path to the outside in all 6 directions
        // X+ direction
        let hasPathX1 = false;
        for (let tx = x + 1; tx <= maxX; tx++) {
          if (!hasBlock(voxels, tx, y, z)) {
            hasPathX1 = true;
            break;
          }
        }
        if (!hasPathX1) {
          // X- direction
          let hasPathX2 = false;
          for (let tx = x - 1; tx >= minX; tx--) {
            if (!hasBlock(voxels, tx, y, z)) {
              hasPathX2 = true;
              break;
            }
          }
          if (!hasPathX2) {
            // Y+ direction
            let hasPathY1 = false;
            for (let ty = y + 1; ty <= maxY; ty++) {
              if (!hasBlock(voxels, x, ty, z)) {
                hasPathY1 = true;
                break;
              }
            }
            if (!hasPathY1) {
              // Y- direction
              let hasPathY2 = false;
              for (let ty = y - 1; ty >= minY; ty--) {
                if (!hasBlock(voxels, x, ty, z)) {
                  hasPathY2 = true;
                  break;
                }
              }
              if (!hasPathY2) {
                // Z+ direction
                let hasPathZ1 = false;
                for (let tz = z + 1; tz <= maxZ; tz++) {
                  if (!hasBlock(voxels, x, y, tz)) {
                    hasPathZ1 = true;
                    break;
                  }
                }
                if (!hasPathZ1) {
                  // Z- direction
                  let hasPathZ2 = false;
                  for (let tz = z - 1; tz >= minZ; tz--) {
                    if (!hasBlock(voxels, x, y, tz)) {
                      hasPathZ2 = true;
                      break;
                    }
                  }
                  if (!hasPathZ2) {
                    // If we get here, this position is internal
                    internalSpaces.push([x, y, z]);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  return internalSpaces;
};

// Generate an mcfunction file with /fill commands
export const exportToMcFunction = (
  voxels: Record<string, BlockType>,
  startX: number = 0,
  startY: number = 0,
  startZ: number = 0
): string => {
  // Check if there are any voxels
  if (Object.keys(voxels).length === 0) {
    // Return a comment and a single block as placeholder so the file isn't empty
    return `# Estrutura vazia criada pelo BlockForge
# Adicionando um bloco marcador na posição de origem
fill ~0 ~0 ~0 ~0 ~0 ~0 minecraft:redstone_block`;
  }
  
  // Find the dimensions of the structure
  let minX = Infinity, minY = Infinity, minZ = Infinity;
  let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
  
  for (const key of Object.keys(voxels)) {
    const [x, y, z] = key.split(',').map(Number);
    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    minZ = Math.min(minZ, z);
    maxX = Math.max(maxX, x);
    maxY = Math.max(maxY, y);
    maxZ = Math.max(maxZ, z);
  }
  
  // Calculate dimensions
  const width = maxX - minX + 1;
  const height = maxY - minY + 1;
  const depth = maxZ - minZ + 1;
  
  // Find internal spaces and fill them with air for export
  const internalSpaces = findInternalSpaces(voxels, minX, minY, minZ, maxX, maxY, maxZ);
  
  // Create a copy of voxels with internal spaces filled with air
  const exportVoxels = { ...voxels };
  internalSpaces.forEach(([x, y, z]) => {
    exportVoxels[`${x},${y},${z}`] = "minecraft:air";
  });
  
  // Optimize voxels into regions
  const regions = optimizeVoxelRegions(exportVoxels, [width, height, depth]);
  
  // Generate header with information
  let mcfunction = [
    "# Generated by BlockForge",
    `# Structure dimensions: ${width}x${height}x${depth}`,
    `# Origin position: ${startX}, ${startY}, ${startZ}`,
    `# Block count: ${Object.keys(voxels).length}`,
    `# Internal spaces filled with air: ${internalSpaces.length}`,
    ""
  ].join("\n");
  
  // Generate /fill commands
  regions.forEach((region: FillRegion) => {
    const { start, end, blockType } = region;
    const [sx, sy, sz] = start;
    const [ex, ey, ez] = end;
    
    // Adjust for structure origin
    const relX1 = startX + sx + minX;
    const relY1 = startY + sy + minY;
    const relZ1 = startZ + sz + minZ;
    const relX2 = startX + ex + minX;
    const relY2 = startY + ey + minY;
    const relZ2 = startZ + ez + minZ;
    
    // Generate fill command with relative coordinates (~)
    // This makes the structure spawn relative to the player's position in Minecraft
    mcfunction += `fill ~${relX1} ~${relY1} ~${relZ1} ~${relX2} ~${relY2} ~${relZ2} ${blockType}\n`;
  });
  
  return mcfunction;
};

// Helper to export as CSV if needed
export const exportToCSV = (
  voxels: Record<string, BlockType>,
  layer: number
): string => {
  // Find the dimensions of the structure
  let minX = Infinity, minZ = Infinity;
  let maxX = -Infinity, maxZ = -Infinity;
  
  // Filter voxels for the specified layer
  const layerVoxels: Record<string, BlockType> = {};
  for (const [key, blockType] of Object.entries(voxels)) {
    const [x, y, z] = key.split(',').map(Number);
    if (y === layer) {
      layerVoxels[`${x},${z}`] = blockType;
      minX = Math.min(minX, x);
      minZ = Math.min(minZ, z);
      maxX = Math.max(maxX, x);
      maxZ = Math.max(maxZ, z);
    }
  }
  
  // If no voxels in this layer, return empty CSV
  if (Object.keys(layerVoxels).length === 0) {
    return "# Empty layer";
  }
  
  // Generate CSV
  let csv = "";
  for (let z = minZ; z <= maxZ; z++) {
    const row: string[] = [];
    for (let x = minX; x <= maxX; x++) {
      const key = `${x},${z}`;
      row.push(layerVoxels[key] || "");
    }
    csv += row.join(",") + "\n";
  }
  
  return csv;
};

// Export the project as JSON
export const exportToJSON = (
  voxels: Record<string, BlockType>,
  dimensions: [number, number, number]
): string => {
  const project = {
    version: "1.0.0",
    dimensions,
    voxels
  };
  
  return JSON.stringify(project, null, 2);
};
